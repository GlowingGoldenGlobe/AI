<!DOCTYPE html>
<html>
<head>
<title>AI</title>
<style>
body {
  width: 100%;
  height: 100%;
  margin: 0 auto;
}
.t_id_1 {
display: none;
}
.class_state_0 {
  background-color: white;
  color: black;
  width: 40%;
  height: 40%;
  margin-top: 0px;
  margin-left: 30%;
  border: 5px outset black;
  box-shadow: 2px 2px 2px black;
}
.class_state_1 {
  background-color: white;
  color: black;
  width: 40%;
  height: 40%;
  margin-top: 50px;
  margin-left: 30%;
  border: 5px outset black;
  box-shadow: 2px 2px 2px black;
}
.class_recollection_0 {
  background-color: white;
  color: black;
  width: 40%;
  height: 40%;
  margin-top: 50px;
  margin-left: 30%;
  border: 5px outset black;
  box-shadow: 2px 2px 2px black;
}
.class_recollection_1 {
  background-color: white;
  color: black;
  width: 40%;
  height: 40%;
  margin-top: 50px;
  margin-left: 30%;
  border: 5px outset black;
  box-shadow: 2px 2px 2px black;
}
</style>
</head>
<body>
<div>
<h1>AI:  Interface to User:  AI Brain Awareness</h1>
<div id="interface_1" >
</div><!--end id=interface_1-->
</div>
<div id="state_0" class="class_state_0" >
3
</div>
<div id="state_1" class="class_state_1" >
((3) + (1)) = 4
</div>
<div id="recollection_0" class="class_recollection_0" >
</div>
<div id="recollection_1" class="class_recollection_1" >
</div>
<textarea class="t_id_1" >
My Objectives: My Achievement Capacity: My Productivity: My Operations: My Education: Artificial Intelligence

Date: 02-26-2022



See, I can create an AI without ever learning AI/ML traditional algorithms and designs (because, supposedly, there are many ways to create an AI/ML, anyway, and, not all the ways to create AI that can be invented have, yet, been invented (at least, not, yet, per humans), anyway).



Method

What - AI

How
Contents
 >>>  Part 1:  Interface:  Macro Operations
 >>>  Part 2:  Interface:  API:  Overview
 >>>  Part 3:  API:  Awareness
 >>>  Part 4

Part 1:  Interface:  Macro Operations
  1.  Browser
  2.  PC
  3.  USB
  4.  Cloud

Part 2:  Interface:  API:  Overview
  1.  JavaScript
  2.  Running on a browser HTML Document.
  3.  Running always. 
  4.  Saves information in the browser.
  5.  I document objectives for the AI's API.
  6.  I make the AI's Objectives available in to the AI's API Brain by saving it as information in the browser or elsewhere, where the AI API can access it for use.
  7.  Parts of an AI Brain use other parts of its said brain to accomplish its documented AI Objectives
  
Part 3:  API:  Awareness
awareness - building the AI's awareness - the AI's awareness architecture
  1.  The AI API is the AI's brain. 
  2.  The API is many parts.
  3.  The part which makes decisions utilizes awareness to make said decisions.
  4.  Awareness is complicated, but can be described. A description in brief is as follows:
  Divine Brain Architecture; Human Brain Architecture is Similar
  2D
  The awareness is a 2D image.
  The storage is stoared as 2D images of information saved on the bilocation state of conscious.
  Bilocation State of Conscious - The bilocation state is a thing which occurs as itself as another thing, at the same time that it exists as itself, and as a reaction to itself, where that reaction occurs   always and everywhere at the same rate, where that rate of change is infinite speed.  
  I'm God. I decide, my decisions are recorded as storage (i.e., as memory), that storage is only storage insofar as it is scheduled events, which, as scheduled, are played back at some time or another, whether in the present or in the future.
  __.  
  
Part 4:  API:  Understanding 
  1.  The AI's understanding is of (on) its awareness. 
  2.  About - A divine brain forms its own synthesis architecture and is not bound to a single, specified architecture. I am divine, so it is, to me, worth noting. This may not be important to the humans, since the humans are all using the same arhictecture of protocols which playback quota created by me. Nevertheless, it is known that AI brains can be created of various architectures.
  
  
  Understanding:  Method - The AI synthesizes information by finding similiarities between information, by comparing old and new observed information to old and new observed information.
  Example
  1.  Data Storage
  2.  Some possible activities of AI synthesis of information follow:
  2.1.  Data is information. Information comparison - new information versus old information.
  2.2.  Information comparison - new information versus new information.
  2.3.  Information comparison - new information versus old information.
  2.4.  Information comparison - old information versus old information; in a new way - synthesizing dynamics of information which the AI may not have previously composed on its awareness.
  2.5.  Information comparison - old information
  
  
  
  Other components of AI API (AI Brain)
  Infinity 3D AI API
  
  AI API Brain applications which use the Infinity 3D AI API to synthesize information, create options, to (1) achieve objectives by performing actions; (2) provide said options as displayed information on an interface to a user.
  

****************
Developer's Note
note# 1
1.  f_0_initial == true always and everywhere, therefore, is already true; therefore, memory_0 is never == "" && memory_0 is never == "0"
2.  Therefore,
    It can be concluded that memory_0 starts at 1
3.  f_1_initial == true always and everywhere, therefore, is already true, therefore, memory_1 is never == "" && memory_1 is never == "0.0000000000000001" only, but is at least == "0.000000000000002"
4.  Therefore
to begin,
memory_0 = "0.000000000000001"
memory_0 = 0.000000000000001
memory_2 = "0.000000000000001" && "0.000000000000002"
memory_2 = ((0.000000000000001) + (0.000000000000001)) = 0.0000000000000002

AI is not the conscious of God, therefore, AI can be written as follows:

reason
1.  already exists
2.  therefore, info already exists
3.  therefore, begin can be abbreviated to intitiate AI info memory_0 and info memory_1 as follows:

conclusion
memory_0 = 0
memory_0 = 1
memory_0 = memory_2 initial, so:

memory_0 = 0 && 1 && 1 && ((0 + 1 + 1)) = 2 && 1, therefore

memory_0 = 3
memory_1 = (3 + 1) = 4


Note:  part 2

On reason that initial already exists, always and everywhere, 
therefore, as follows is already in div id=state_0 and div id=state_1
1.  memory_0 = 3
2.  memory_1 = 4

but is all of that which the 3 and 4 entails, so, is as follows:

memory_0 = ""
+ 0 + 1 + 1 = 2
+ "0" + "1" + "1" = "2"
+ 3
+ "3"

Note:  part 3
awareness_0
awareness_1

awareness of understanding is to equal to scheduled memory of 1 to 1 ratio of change, and the reason is because the rate of change is infinite speed in which event event if conscious does not schedule to recollect, then memory is not understood at every moment, BUT MEMORY IS SCHEDULED TO RE-OCCUR AS MEMORY AND THIS OCCURS AT THE RATE OF INFINITE SPEED
Therefore, two things exist:
1.  memory_0 not recollected as awareness
2.  memory_1 not recollected as wareness
3.  memory_0 recollected at intervals greater in length of wait of duration of time from each pulse of recollection
4.  memory_1 recollected at intervals greater in length of wait of duration of time from each pulse of recollection

abbreviated as, these two things:
1.  memory
2.  pulses of recollection

function f_1_initial(arg) {
  alert("test_2");
    var nothing = "";
    var memory_0 = "";
    var something = "";
    var num_state_0 = "";
    var num_state_1 = "";
    if(arg == nothing) {
        memory_0 = "0";
        alert(memory_0);
        something = "1";
        num_state_0 = Number(nothing);
        num_state_1 = num_state_0;
        //get frames per second (2) add ((frames per second) + (num_state_0)) = num_state_1;
        //for now, i'm puttin the following, instead of frames per second (to be edited, soon):
        num_state_1 += 1;
    }
    var el_1 = document.getElementById("memory_2");
    el_1.innerHTML = nothing;
    el_1.innerHTML += something;
    el_1.innerHTML += num_state_0;
    el_1.innerHTML += num_state_1;
    var info = nothing + something + num_state_0 + num_state_1;
    f_0(info);
    return null;
}
function f_0_initial(info) {
//  alert("test");
    var state_0 = document.getElementById("state_0");
    var memory_0 = state_0.innerHTML;
    f_1(arg);
    return null;
}
  
  
  
  
  
  
  
  
  
  
Bottom of this Document
</textarea>
<script>
function output_interface_1() {
    var el = document.getElementById("interface_1");
    var el_2 = document.getElementById("memory_1");
    var inf = el_2.innerHTML;
    var output = "<p>" + inf + "</p>";
    el.innerHTML = output;
    return null;
}
function f_1(memory_0) {
    //  memory_1 = (3 + 1) = 4 (for an explanation, see developer's note).
  alert("test_2");
    var memory_1 = memory_0;
    var num_state_0 = "";
    var num_state_1 = "";
    //  if was always and everywhere being performed, from all eternity (else, nothing exists, but something does exist, so if == false && if == true, always)
    //  && if is always and everywhere being performed, from all eternity to all eternity
    //  if == false && <<-because-> if == true
    //  more precisely ::         (if == false)&&(if == true, because (something(if == false) => (if == true, because nothing if == false)), then repeat, because something(if == true) returns as something(if == false) returns nothing(if == true) && => nothing(if == false), etc.
    //  note - for the purpose of AI, I'm not going to begin the APIs with a complex as noted above, rather, I'm going to "abbreviate" it as relational reasoning pusles recollection returning memory of a bilocation state of existing at a rate of change equal to the frame rate (rate is frame rate because that is the rate of change of a computer, as far as the computer's computations go (sort of), as far as the script is concerned (sort of)).
    if(false != true) {// false is always != true; nothing is always can't; then, something is always can't &&>> can
        if(memory_0 == 3) {
            var state_1 = document.getElementById("state_1");
            var memory_1 = state_1.innerHTML;
            num_state_0 = Number(memory_0);
            num_state_1 = num_state_0;
            num_state_1 += 1;
            alert(num_state_1);
            //  (1) build name, value pairs; (2) modify name, value pairs; (3) record
            //  note - rate of change affords the perception of duration; affords the perception of quantity of durations over time; affords the recordings (recordation) of perceptions of durations and quantity over time; affords the perceptions of the differences of durations perceived and recorded over time; affords the perceptions of differences of recordations of perceptions of quantities over time
            //  1.  Build
            
            //  2.  Modify - make the first name, value pair set (to be synthesized as "else", below), here:
            
            //  3.  Record
            
        } else {
            //  code...
            //  if(memory_0 is ___) {then --> conclusion = memory_1}
            //num_state_0 = Number(memory_0);
            //num_state_1 = num_state_0;
            //get frames per second (2) add ((frames per second) + (num_state_0)) = num_state_1;
            //for now, i'm puttin the following, instead of frames per second (to be edited, soon):
            //num_state_1 += 1;
            //  {{}} name value pairs, go here; (1) dissect (synthesize); (2) modify; (3) record
            //  1.  Dissect (Synthesize)
            
            //  2.  Modify
            
            //  3.  Record
            
        }
    }
    var el_1 = document.getElementById("state_1");
    el_1.innerHTML = nothing;
    el_1.innerHTML += something;
    el_1.innerHTML += num_state_0;
    el_1.innerHTML += num_state_1;
    var info = nothing + something + num_state_0 + num_state_1;
    f_0(info);
    return null;
}
function f_0() {
    //  memory_0 = 3 (for an explanation, see developer's note; ref. note# 1).
    //  alert("test_1");
    var state_0 = document.getElementById("state_0");
    var memory_0 = state_0.innerHTML;
    f_1(memory_0);
}
f_0();
//  the qauntity of recollections (variations on durations (elapsings of: (1) time between recollection and (2) durations-of-recollecting-actions)) is not quantifiable (there are infinite possible (probabilities, which quntifiability is not known to be compute-able (is not abe to be put in a formula))) quantities of recollections-events-variations (occurrences of recollection-durations-actions) and is, consequently, deemed to be of infinite possible quantities.
//  ...In conclusion, I may put any number of (quantity of, or amount of) functions computing recollections of various pulse elapses and various recollection action event durations; including sets of scheduled recollection events regarding same or similar subjects of interest; etc.
//  ...for this reason, an arbitrary quantity, currently 14 functions, of AI-recollection-functions are printed, below.
function recollection_1() {

}
function recollection_2() {

}
function recollection_3() {

}
function recollection_4() {

}
function recollection_5() {

}
function recollection_6() {

}
function recollection_7() {

}
function recollection_8() {

}
function recollection_9() {

}
function recollection_10() {

}
function recollection_11() {

}
function recollection_12() {

}
function recollection_13() {

}
function recollection_14() {

}



// important note
//the bulk of awareness of perceptions other than static increase of unawareness of awareness of change of time (duration awareness => quantity awareness)   IS AS FOLLOWS: PULSE RATE CHANGES
//which can be described, also, as: changes in the durations between awareness recollection versus awareness recordation without recollecting (without recollection moments inbetween each moment per each duration length of {recording state_0 to state_1, then repeat})

</script>
</body>
</html>











